<!DOCTYPE html>
<html>
  <head>
    <title>README</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <div class="breadcrumbs">exactor v0.7.0 &rarr; <a href="readme.html">README</a></div>
      <h1 id="exactor">ExActor</h1>
<p>Simplified implementation and usage of <code>gen_server</code> based actors in Elixir. This library is inspired by (though not depending on) <a href="https://github.com/yrashk/genx">GenX</a>, but in addition, removes some more boilerplate, and changes some semantics of the handle_call/cast responses.</p>
<p>If you're new to Erlang, and are not familiar on how gen_server works, I strongly suggest you learn about it first. It's really not that hard, and you can use <a href="http://elixir-lang.org/docs/stable/elixir/GenServer.html">Elixir docs</a> as the starting point. Once you're familiar with gen_server, you can use ExActor to make your actors (gen_servers) more compact.</p>
<p>Status: I use it in production.</p>
<p>Online documentation is available <a href="http://sasa1977.github.io/exactor/">here</a>.</p>
<p>The stable package is also available on <a href="https://hex.pm/packages/exactor">hex</a>.</p>
<h2 id="basic-usage">Basic usage</h2>
<p>Be sure to include a dependency in your <code>mix.exs</code>:</p>
<pre class="elixir"><code>deps: [{:exactor, &quot;~&gt; 0.7.0&quot;}, ...]</code></pre>
<pre class="elixir"><code>defmodule Actor do
  use ExActor.GenServer

  definit do: initial_state(some_state)

  defcast inc(x), state: state, do: new_state(state + x)

  defcall get, state: state, do: reply(state)
  defcall long_call, state: state, timeout: :timer.seconds(10), do: heavy_transformation(state)

  # Interface functions foo and bar are private to this module. This is useful when
  # you need to do pre/post processing in the client process. You can simply create a plain
  # exported interface function, and then call these private functions to issue request to
  # the server process.
  defcastp foo, ...
  defcallp bar, ...

  definfo :some_message, do: ...
end

# initial state is set to start argument
{:ok, act} = Actor.start(1)
Actor.get(act)         # 1

Actor.inc(act, 2)
Actor.get(act)         # 3</code></pre>
<h2 id="predefines">Predefines</h2>
<p>A predefine is an ExActor mixin that provides some default implementations for <code>gen_server</code> callbacks. Following predefines are currently provided:</p>
<ul>
<li><code>ExActor.GenServer</code> - All <code>gen_server</code> callbacks are provided by GenServer from Elixir standard library.</li>
<li><code>ExActor.Strict</code> - All <code>gen_server</code> callbacks are provided. The default implementations for all except <code>code_change</code> and <code>terminate</code> will cause the server to be stopped.</li>
<li><code>ExActor.Tolerant</code> - All <code>gen_server</code> callbacks are provided. The default implementations ignore all messages without stopping the server.</li>
<li><code>ExActor.Empty</code> - No default implementation for <code>gen_server</code> callbacks are provided.</li>
</ul>
<p>It is up to you to decide which predefine you want to use. See online docs for detailed description. You can also build your own predefine. Refer to the source code of the existing ones as a template.</p>
<h2 id="singleton-actors">Singleton actors</h2>
<pre class="elixir"><code>defmodule SingletonActor do
  # The actor process will be locally registered under an alias
  # provided in export option.
  use ExActor.GenServer, export: :some_registered_name

  # you can also use via, and global
  # use ExActor.GenServer, export: {:global, :some_registered_name}
  # use ExActor.GenServer, export: {:via, :gproc, :some_registered_name}

  defcall get, state: state, do: reply(state)
  defcast set(x), do: new_state(x)
end

SingletonActor.start
SingletonActor.set(5)
SingletonActor.get</code></pre>
<h2 id="handling-of-return-values">Handling of return values</h2>
<pre class="elixir"><code>definit do: initial_state(arg)                      # sets initial state
definit do: {:ok, arg}                              # standard gen_server response

defcall a, state: state, do: reply(response)        # responds 5 but doesn&#39;t change state
defcall b, do: set_and_reply(new_state, response)   # responds and changes state
defcall c, do: {:reply, response, new_state}        # standard gen_server response

defcast c, do: noreply                              # doesn&#39;t change state
defcast d, do: new_state(new_state)                 # sets new state
defcast f, do: {:noreply, new_state}                # standard gen_server response

definfo c, do: noreply                              # doesn&#39;t change state
definfo d, do: new_state(new_state)                 # sets new state
definfo f, do: {:noreply, new_state}                # standard gen_server response</code></pre>
<h2 id="simplified-starting">Simplified starting</h2>
<pre class="elixir"><code>Actor.start                           # same as Actor.start(nil)
Actor.start(init_arg)
Actor.start(init_arg, options)

Actor.start_link                      # same as Actor.start_link(nil)
Actor.start_link(init_arg)
Actor.start_link(init_arg, options)</code></pre>
<h3 id="dynamic-registration">Dynamic registration</h3>
<pre class="elixir"><code>Actor.start(init_arg, name: :some_registered_name, ...)                   # registers locally
Actor.start(init_arg, name: {:local, :some_registered_name}, ...)         # registers locally
Actor.start(init_arg, name: {:global, :some_registered_name}, ...)        # registers globally
Actor.start(init_arg, name: {:via, :gproc, :some_registered_name}, ...)   # registers via external module

# same for start_link</code></pre>
<p>Starter functions are overridable. You can optionally specify that you don't want them:</p>
<pre class="elixir"><code>  use ExActor.GenServer, starters: false</code></pre>
<h2 id="simplified-initialization">Simplified initialization</h2>
<pre class="elixir"><code># define initial state
use ExActor.GenServer, initial_state: HashDict.new

# alternatively as the function
definit do: HashSet.new

# using the input argument
definit x do
  x + 1
  |&gt; initial_state
end</code></pre>
<h2 id="handling-messages">Handling messages</h2>
<pre class="elixir"><code>definfo :some_message, do:
definfo :another_message, state: ..., do:</code></pre>
<h2 id="pattern-matching">Pattern matching</h2>
<pre class="elixir"><code>defcall a(1), do: ...
defcall a(2), do: ...
defcall a(x), state: 1, do: ...
defcall a(x), when: x &gt; 1, do: ...
defcall a(x), state: state, when: state &gt; 1, do: ...
defcall a(_), do: ...

definit :something, do: ...
definit x, when: ..., do: ...

definfo :msg, state: {...}, when: ..., do: ...</code></pre>
<p>Note: all call/cast matches take place at the <code>handle_call</code> or <code>handle_cast</code> level. The interface function simply passes the arguments to appropriate <code>gen_server</code> function. Consequently, if a match fails, the server will crash.</p>
<h2 id="skipping-interface-funs">Skipping interface funs</h2>
<pre class="elixir"><code># interface fun will not be generated, just handle_call clause
defcall unexported, export: false, do: :unexported</code></pre>
<h2 id="using-from">Using from</h2>
<pre class="codeblock"><code>defcall a(...), from: {from_pid, ref} do
  ...
end</code></pre>
<h2 id="runtime-friendliness">Runtime friendliness</h2>
<p>May be useful if calls/casts simply delegate to some module/functions.</p>
<pre class="elixir"><code>defmodule DynActor do
  use ExActor.GenServer

  for op &lt;- [:op1, :op2] do
    defcall unquote(op), state: state do
      SomeModule.unquote(op)(state)
    end
  end
end</code></pre>
<h2 id="simplified-data-abstraction-delegation">Simplified data abstraction delegation</h2>
<p>Macro <code>delegate_to</code> is provided to shorten the definition when the state is implemented as a functional data abstraction, and operations simply delegate to that module. Here's an example:</p>
<pre class="elixir"><code>defmodule HashDictActor do
  use ExActor.GenServer
  import ExActor.Delegator

  delegate_to HashDict do
    init
    query get/2
    trans put/3
  end
end</code></pre>
<p>This is equivalent of:</p>
<pre class="elixir"><code>defmodule HashDictActor do
  use ExActor.GenServer

  definit do: HashDict.new

  defcall get(k), state: state do
    HashDict.get(state, k)
  end

  defcast put(k, v), state:state do
    HashDict.put(state, k, v)
    |&gt; new_state
  end
end</code></pre>
<p>You can freely mix <code>delegate_to</code> with other macros, such as <code>defcall</code>, <code>defcast</code>, and others.</p>

    </div>
  </body>
</html>

